<!DOCTYPE html><html><head><title>Adventure Kingdom</title><style>body{background-color:#000}canvas{position:fixed;left:0;top:0;width:100%;height:100%;object-fit:contain;image-rendering:pixelated;z-index:1}h1{z-index:2;opacity:0}</style></head><body><script>var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var algo = {
    // Catalan Number, Dyck Word, Random Generation
    cdr: function (length) {
        if (length < 2)
            return length;
        var o = 0, x = 0, y = 0;
        for (var i = 0; i < 2 * length; i++) {
            if (x >= length)
                break;
            if (x == y || Math.random() < 0.5) {
                o += Math.pow(2, i);
                x++;
            }
            else
                y++;
        }
        return o;
    },
    cdr_it: function (seed, length, loop) {
        loop(3, 0, 0, true);
        var h = 1;
        for (var i = 1; i < length - 1; i++) {
            var p = seed & 3;
            seed = seed >> 2;
            if (p == 0)
                h--;
            loop(p, h, i, false);
            if (p == 3)
                h++;
        }
        loop(0, 0, length - 1, true);
    },
    // Physics - Responsable for Gravity, Momentum, Collision
    // (delta_time, entity.[m,hitbox,collide,nocollide]) => (entity.[x,y,m,ground])
    gravity: 9,
    physics: function (delta_time, entity) {
        // Calculate Momentum and difference Position
        var m = [entity.m[0], entity.m[1] - (algo.gravity + entity.m[1]) * delta_time / 500];
        var p = [m[0] * delta_time / 50, -m[1] * delta_time / 50];
        var c = [];
        entity.ground = -1;
        entity.collide.forEach(function (collider, id) {
            if (entity.nocollide.indexOf(id) != -1)
                return;
            for (var a = 0; a < 4; a++) {
                // Would have been easier if hitbox was [N,W,S,E] instead
                // Optional (a+1)>>1&1 instead
                var A = a == 1 || a == 2 ? collider : entity;
                var B = a == 1 || a == 2 ? entity : collider;
                if (entity.hitbox[0] >> a & 1 && collider.hitbox[0] >> ((a + 2) % 4) & 1 &&
                    A.hitbox[2 - a % 2] >= B.hitbox[2 - a % 2] + B.hitbox[4 - a % 2] &&
                    A.hitbox[2 - a % 2] + p[1 - a % 2] * (a == 1 || a == 2 ? -1 : 1) < B.hitbox[2 - a % 2] + B.hitbox[4 - a % 2] &&
                    entity.hitbox[1 + a % 2] < collider.hitbox[1 + a % 2] + collider.hitbox[3 + a % 2] &&
                    entity.hitbox[1 + a % 2] + entity.hitbox[3 + a % 2] > collider.hitbox[1 + a % 2]) {
                    p[1 - a % 2] = collider.hitbox[2 - a % 2] - entity.hitbox[2 - a % 2] + B.hitbox[4 - a % 2] * (a == 1 || a == 2 ? -1 : 1);
                    m[1 - a % 2] = 0;
                    if (a == 2)
                        entity.ground = id;
                    c.push([id, a]); // There can only be 1 side of collision, no need binary set
                }
            }
        });
        entity.x += p[0];
        entity.y += p[1];
        entity.m = m;
        return c;
    },
    /*
    collision: (entity:{[index:string]:any}, area?:number):number[] => {
        let collide:number[] = [0, -1];
        let d = area == undefined ? 15 : area;
        entity.collide.forEach((collider,num) => {
            if (entity.hitbox[0]&4 && collider.hitbox[0]&1 && (d&4) == 4 &&
                entity.hitbox[2]+entity.hitbox[4] >= collider.hitbox[2] &&
                entity.hitbox[2]+entity.hitbox[4] < collider.hitbox[2]+collider.hitbox[4] &&
                entity.hitbox[1] < collider.hitbox[1]+collider.hitbox[3] &&
                entity.hitbox[1]+entity.hitbox[3] > collider.hitbox[1]
            ) collide = [4, num];
        });
        return collide;
    },
    collide: (entity:{[index:string]:any}, area?:number):boolean => {
        let collided = algo.collision(entity, area);
        if (collided[1] == -1) return false;
        if (collided[0] == 4) entity.hitbox[2] = entity.y = entity.collide[collided[1]].hitbox[2]-entity.hitbox[4];
        return true;
    },
    // Physics - Responsable for Momentum, Gravity, Collision
    /*physics: (entity:{m:number[], [index:string]:any}, dt:number, ...colliders:{[index:string]:any}[]) => {
        // Momentum
        
    }*/
    rseed: function (seed) {
        var x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
    },
    prng: function (seed, len, pos) {
        var chunk = [];
        for (var i = 0; i < len; i++)
            chunk.push(algo.rseed(seed + pos * len + i));
        return chunk;
    }
};
var required_files = [
    // Menu
    'Rise_of_the_Aswang_King.png',
    // Background
    'dark bg.png', 'normal bg.png', 'normal clouds.png', 'Housesv2.png',
    // Platforms
    'Flowers.png', 'Bgitems.png', 'Blocks.png', 'Trees.png', 'Lagablab, bubble and random vegetation.png',
    // Entities
    'Dog.png', 'Cat (1).png', 'Aswang King.png', 'Arrow.png', 'Mananangalv3.png',
    // Player
    'Mcparts.png',
    // Music
    'song/1st Temp BG Song (New Area).mp3'
];
var entities = {
    // Pinoy Entitiy
    pinoy: {
        default: {
            x: 0, y: 0, m: [0, 0], hitbox: [], collide: [], nocollide: [],
            isdead: false, // Is character dead?
            crouch: false, // Is character crouching?
            jumping: false, // Is character jumping?
            fright: true, // Is character facing right?
            camera: true, // Is camera on character?
            swing: false, // Is character swinging sword?
            swinging: 0, // Current swining position (0->1)
            dead: -1, // Level of deadness (-1 Not dead, 0->1 Dying)
            ground: -1, // Collider character is on
        },
        update: function (d, o, t, dt) {
            var c = function (n) { return [n % 6, Math.floor(n / 6)]; };
            var leg = [0, 0], body = [0, 0];
            if (d.dead == -1) {
                // Hitbox
                d.hitbox = [15,
                    d.x + 12, d.y,
                    8, 29
                ];
                // Movement
                d.fright = d.m[0] > 0 ? true : d.m[0] < 0 ? false : d.fright;
                var cols = algo.physics(dt, d);
                if (d.crouch && !d.jumping)
                    cols.forEach(function (c) {
                        if (c[1] == 2 && d.collide[c[0]].dropoff)
                            d.nocollide.push(c[0]);
                    });
                else
                    d.nocollide = [];
                if (d.y >= o.h - 32)
                    d.dead = 0;
                // Camera
                if (d.camera) {
                    //o.camera[0] = d.x-o.w/2;
                    o.camera[0] += (d.x - o.w / 2 - o.camera[0]) * dt / 100;
                }
                // Sword
                if (d.swing && d.dead == -1) {
                    d.swinging += (1 - d.swinging) * dt / 100;
                    if (d.swinging > 0.9)
                        d.swing = false;
                }
                else
                    d.swinging -= d.swinging * dt / 100;
                var s = Math.round(d.swinging * 2.4);
                leg = c(d.ground == -1 ? 8 :
                    d.crouch ? 7 :
                        Math.abs(d.m[0]) > 0.5 ? 1 + Math.floor(t / 50) % 6 :
                            0);
                body = c(s > 0 ? 27 + s :
                    d.ground == -1 ? 26 :
                        d.crouch ? 25 :
                            Math.abs(d.m[0]) > 0.5 ? 13 + Math.floor(t / 50) % 12 :
                                12);
            }
            if (d.dead != -1) {
                d.y = o.h - 33;
                leg = c(9);
                body = c(27);
                d.dead += (1 - d.dead) * dt / 300;
                if (d.dead > 0.99) {
                    d.dead = -1;
                    d.x = 0;
                    d.y = 195;
                }
            }
            // Rendering
            o.sprites('Mcparts.png', [d.x, d.y - (d.dead == -1 ? 0 : 21 * Math.sin(1.32 * (d.dead * d.dead + 0.133) * Math.PI) - 11)], 
            // Leg
            [0, 0, 32 * leg[0], 32 * leg[1], 32, 32, 1 - d.fright], 
            // Body
            [0, d.crouch ? 2 : 0, 32 * body[0], 32 * body[1], 32, 32, 1 - d.fright]);
        }
    },
    // Background Entity
    background: {
        default: {
            darkmode: false,
            dark: 0,
            house: false
        },
        update: function (d, o, t, dt) {
            if (d.darkmode)
                d.dark += (1 - d.dark) * dt / 1000;
            else
                d.dark -= d.dark * dt / 1000;
            o.draw('', { img: 'normal bg.png' });
            o.draw('', { img: 'dark bg.png', alpha: d.dark });
            if (d.house)
                o.sprites('Housesv2.png', [], [-150, 100, 126, 0, 128, 128]);
        }
    },
    pet: {
        default: { x: 0, y: 0, m: [0, 0], animal: 0, jumping: false, ground: -1, collide: [], nocollide: [], hitbox: [] },
        update: function (d, o, t, dt) {
            // Hitbox
            d.hitbox = [15,
                d.x, d.y,
                26, 15
            ];
            // Follow AI
            if (d.follow != undefined && d.follow.dead == -1) {
                d.m[0] = Math.abs(d.follow.x + (d.follow.x > d.x ? -15 : 15) - d.x) < 15 ? 0 : d.follow.x > d.x ? 7 : -7; //(d.follow.x+(d.follow.x>d.x?-10:10)-d.x)/10;
                if (Math.abs(d.follow.y - d.y) > o.h) {
                    d.x = d.follow.x;
                    d.y = d.follow.y;
                }
                // Jump
                if (d.follow.ground != -1 && d.follow.collide[d.follow.ground].y < d.y && !d.jumping) {
                    d.m[1] = 20; //16;
                    d.jumping = true;
                }
                else if (d.follow.ground != -1 && d.ground != -1 && d.follow.collide[d.follow.ground].y > d.y + 16) {
                    d.nocollide = [d.ground];
                }
            }
            else
                d.m[0] = 0;
            // Movement
            d.fright = d.m[0] > 0 ? true : d.m[0] < 0 ? false : d.fright;
            algo.physics(dt, d);
            if (d.ground != -1) {
                d.jumping = false;
                d.nocollide = [];
            }
            // Render
            var x = (Math.abs(d.m[0]) > 0.15 ? 1 + Math.floor(t / 100) % 2 : 0);
            if (d.animal == 0)
                o.sprites('Dog.png', [d.x, d.y], [0, 0, x * 32 + 3, 8, 26, 15, 1 - d.fright]);
            else if (d.animal == 1)
                o.sprites('Cat (1).png', [d.x, d.y], [0, 0, x * 16, 0, 16, 16, 1 - d.fright]);
        }
    },
    king: {
        default: { x: 0, y: 100,
            wing_angle: 0
        },
        update: function (d, o, t, dt) {
            d.wing_angle = Math.sin(t / 150);
            o.sprites('Aswang King.png', [d.x, d.y], 
            // Right wing
            [61, 1 + Math.sin(t / 200), 35, 0, 35, 18, 0, 0, -d.wing_angle, 0, 18], 
            // Left wing
            [0, Math.sin(t / 200), 0, 0, 35, 18, 0, 0, d.wing_angle, 35], 
            // Left hand
            [1, 24 + Math.sin(t / 200) / 2, 0, 18, 23, 21, 0, 0, 0], 
            // Right hand
            [66, 24 + Math.sin(t / 200) / 2, 23, 18, 23, 21], 
            // Body
            [28, 13 + Math.sin(t / 200), 0, 39, 37, 52], 
            // Head
            [41, 1 + Math.sin(t / 200) * 2, 70, 0, 13, 18]);
        }
    },
    arrow: {
        default: { x: 0, y: 0, m: [0, 0], a: 0 },
        update: function (d, o, t, dt) {
            if (d.y < 220) {
                d.x += d.m[0] * dt / 50;
                //d.y -= algo.gravity(d.m, dt);
                d.a += (Math.atan2(d.m[1], -d.m[0]) - d.a) * dt / 200;
            }
            o.sprites('Arrow.png', [d.x, d.y], [0, 0, 0, 0, 8, 5, 0, 0, d.a, 4, 3]);
        },
        create: function (o, arg) {
            return __assign({ m: [5 - 10 * Math.random(), 5 - 10 * Math.random()] }, arg);
        }
    },
    plat: {
        default: { x: 0, y: 0, w: 0, h: 0, hitbox: [], dropoff: true },
        update: function (d, o, t, dt) {
            var bs = [];
            for (var y = 0; y < d.h * 2; y++) {
                for (var x = 0; x < d.w * 2; x++) {
                    bs.push([
                        8 * x, 8 * y,
                        x == 0 ? 23 : x + 1 == d.w * 2 ? 31 : 27,
                        y == 0 ? 22 : y + 1 == d.h * 2 ? 34 : 30,
                        8, 8
                    ]);
                }
            }
            for (var x = 0; x < d.w; x++) {
                if (d.data[x] & 8)
                    o.sprites('Lagablab, bubble and random vegetation.png', [d.x, d.y], [32 * x, -32, 0, 0, 32, 32]);
                if (d.data[x] & 4)
                    o.sprites('Lagablab, bubble and random vegetation.png', [d.x, d.y], [32 * x, -32, 32, 0, 32, 32]);
                if (d.data[x] & 2)
                    o.sprites('Trees.png', [d.x, d.y], [32 * x, -64, 0, 0, 64, 64]);
                if (d.data[x] & 1)
                    o.sprites('Flowers.png', [d.x, d.y], [32 * x, -32, 0, 0, 32, 32]);
            }
            o.sprites.apply(o, __spreadArray(['Blocks.png', [d.x, d.y]], bs, false));
            d.hitbox = [1,
                d.x, d.y,
                d.w * 16, d.h * 16
            ];
        },
        create: function (o, arg) {
            var w = arg.w || 0;
            var d = [];
            for (var i = 0; i < w >> 1; i++)
                d.push(
                // Grass
                (Math.random() < 0.5 ? 1 : 0) +
                    // Tree
                    (Math.random() < 0.1 ? 2 : 0) +
                    // Big Grass
                    (Math.random() < 0.2 ? 4 : 0) +
                    // Bush
                    (Math.random() < 0.1 ? 8 : 0));
            return __assign({ data: d }, arg);
        }
    },
    setting: {
        default: { seed: 0, width: 0, data: [] },
        update: function (d, o, t, dt) {
            // Flowers
            for (var i = 0; i < d.data.length >> 1; i++) {
                if (d.data[i] > 0.5)
                    o.sprites('Flowers.png', [32 * i, 190], [0, 0, 0, 0, 32, 32]);
            }
            // Objects
            for (var i = 0; i < d.data.length >> 1; i++) {
                var p = d.data[i + (d.data.length >> 1)];
                if (p > 0.5) {
                    var n = Math.floor(2 * (p - 0.5) * 17);
                    o.sprites('Bgitems.png', [32 * i + 5 - 20 * (p - 0.5), 190 + 10 * (p - 0.5)], [0, 0, 32 * (n % 4), 32 * Math.floor(n / 4), 32, 32]);
                }
            }
        },
        create: function (o, arg) {
            var seed = Number(new Date());
            var w = 20;
            return __assign({ seed: seed, data: algo.prng(seed, w * 2, 0), width: w }, arg);
        }
    },
    menu: {
        default: {},
        update: function (d, o, t, dt) {
            o.sprites('Rise_of_the_Aswang_King.png', [-128, 0], [0, 0, 0, 0, 256, 144]);
        }
    },
    mananangal: {
        default: { x: 0, y: 0, t: 0 },
        update: function (d, o, t, dt) {
            var c = [
                // Body
                [0, 0, 0, 0, 32, 32],
                // Wing
                [0, 1, 32 * 3, 0, 32, 32, 0, 0, Math.sin(t / 100) * 0.5 - 0.5, 11, 19]
            ];
            var tng = Math.floor(d.t * 4);
            if (tng > 0)
                c.push([7, 8, Math.floor(t / 100) % 3 * 32, 32 * 3, 32, 32, 0, 0, 0]);
            o.sprites.apply(o, __spreadArray(['Mananangalv3.png', [d.x, d.y + Math.sin(t / 200) * 0.5]], c, false));
        }
    }
};
var engine = /** @class */ (function () {
    function engine(args) {
        var _this = this;
        this.fps = 60; // Frames per second
        this.camera = [0, 0];
        // Loader
        this.loaded = {}; // Loaded data in cache
        this.evented = {}; // Recorded events
        this.events = {}; // Global event listeners
        this.scenes = {}; // Scenes
        this.active_scene = ''; // Active Scene
        this.path = ''; // Current path of action (scene)
        this.audios = {}; // Current playing audios
        // Drawing
        this.sprite_boxed = false;
        this.hitbox_boxed = false;
        this.rotate_boxed = false;
        // Initalize Canvas
        args = args === undefined ? {} : args;
        Object.keys(args).forEach(function (key) {
            if (key == 'load')
                return;
            _this[key] = args[key];
        });
        this.dom = document.createElement('canvas');
        if (args.dom)
            this.dom = args.dom;
        this.w = args.w || 320;
        this.h = args.h || 240;
        this.dom.setAttribute('width', String(this.w * this.z));
        this.dom.setAttribute('height', String(this.h * this.z));
        this.ctx = this.dom.getContext('2d');
        this.ctx.imageSmoothingEnabled = false;
        if (Object.keys(args).indexOf('load') != -1)
            this.load.apply(this, args['load']);
    }
    engine.prototype.loadcheck = function (percent) {
        var _this = this;
        this.ctx.fillRect((this.w * 0.25 + 2) * this.z, (this.h * 0.45 + 2) * this.z, percent * (this.w * 0.5 - 4) * this.z, (this.h * 0.1 - 4) * this.z);
        if (percent < 1)
            return;
        var check = function () {
            for (var i = 0; i < Object.keys(_this.loaded).length; i++)
                if (Object.keys(_this.loaded)[i].slice(-4) == '.ttf' && !document.fonts.check("20px ".concat(Object.keys(_this.loaded)[i].slice(0, -4)))) {
                    setTimeout(check, 10);
                    return;
                }
            _this.start_loop();
        };
        check();
    };
    engine.prototype.load = function () {
        var _this = this;
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        var loaded = [];
        // Loading Menu
        this.ctx.lineWidth = this.z;
        this.ctx.strokeStyle = this.ctx.fillStyle = '#FFFFFF';
        this.ctx.strokeRect(this.w * this.z * 0.25, this.h * this.z * 0.45, this.w * this.z * 0.5, this.h * this.z * 0.1);
        // Loading Files
        files.forEach(function (file, i) {
            var ext = file.slice(-4);
            if (ext == '.png') {
                _this.loaded[file] = new Image();
                _this.loaded[file].src = file;
                _this.loaded[file].onload = function () {
                    loaded[i] = 4;
                    _this.loadcheck(loaded.reduce(function (pre, cur) { return pre + cur; }) / files.length / 4);
                };
            }
            else if (ext == '.ttf' || ext == '.mp3') {
                loaded[i] = 0;
                _this.loaded[file] = '';
                var h_1 = new XMLHttpRequest();
                h_1.open('GET', file);
                h_1.responseType = 'blob';
                h_1.onreadystatechange = function () {
                    loaded[i] = h_1.readyState;
                    _this.loadcheck(loaded.reduce(function (pre, cur) { return pre + cur; }) / files.length / 4);
                    if (h_1.readyState != 4 || h_1.status != 200)
                        return;
                    _this.loaded[file] = URL.createObjectURL(h_1.response);
                    if (ext == '.ttf') {
                        var d = document.createElement('h1');
                        d.style.font = "20px ".concat(file.slice(0, -4));
                        d.innerHTML = file.slice(0, -4);
                        var s = document.createElement('style');
                        s.innerHTML += "@font-face {font-family:\"".concat(file.slice(0, -4), "\";src:url(\"").concat(_this.loaded[file], "\") format(\"truetype\");}");
                        document.head.appendChild(s);
                        document.body.appendChild(d);
                    }
                };
                h_1.send();
            }
        });
    };
    engine.prototype.check_event = function (event, action) {
        var events = event.split(',');
        var index = -1;
        for (var i = 0; i < Object.keys(this.evented).length; i++) {
            if (events.indexOf(Object.keys(this.evented)[i]) != -1) {
                index = i;
                break;
            }
        }
        if (index != -1 && action != undefined) {
            action(this.evented[Object.keys(this.evented)[index]]);
            this.evented[Object.keys(this.evented)[index]]['init'] = false;
        }
        return index != -1;
    };
    engine.prototype.loop = function () {
        var _this = this;
        var now = new Date();
        if (this.active_scene.length != 0) {
            Object.keys(this.audios).forEach(function (audio) {
                if (!_this.audios[audio].hasAttribute('single'))
                    _this.audios[audio].removeAttribute('active');
            });
            this.path = this.active_scene;
            this.scenes[this.active_scene](now.getTime() - this.time_init.getTime(), now.getTime() - this.time_last.getTime());
            this.path = '';
            Object.keys(this.audios).forEach(function (audio) {
                if (_this.audios[audio].hasAttribute('active'))
                    _this.audios[audio].play();
                else
                    _this.audios[audio].pause();
            });
        }
        Object.keys(this.events).forEach(function (e) {
            _this.events[e].forEach(function (a) { return _this.check_event(e, a); });
            if (_this.events[e].hasOwnProperty('init'))
                _this.events[e]['init'] = false;
        });
        this.time_last = new Date();
    };
    engine.prototype.start_loop = function () {
        this.time_init = new Date();
        this.time_last = new Date();
        this.looper = window.setInterval(this.loop.bind(this), 1000 / this.fps);
    };
    engine.prototype.stop_loop = function () {
        clearInterval(this.looper);
    };
    engine.prototype.scene = function (id, scene) {
        if (scene == undefined || this.active_scene.length == 0)
            this.active_scene = id;
        if (scene != undefined)
            this.scenes[id] = scene;
    };
    engine.prototype.on = function (event, action) {
        if (this.path.length == 0) {
            if (action == undefined)
                throw "Error: Action in \"engine.on\" must be decleared if not inside scene";
            if (!this.events.hasOwnProperty(event))
                this.events[event] = [];
            this.events[event].push(action);
            return false;
        }
        return this.check_event(event, action);
    };
    engine.prototype.play = function (audio, single) {
        if (single) {
            this.audios[audio] = new Audio();
            this.audios[audio].src = this.loaded[audio];
            this.audios[audio].play();
            this.audios[audio].setAttribute('single', '');
        }
        else {
            if (!this.audios[audio]) {
                this.audios[audio] = new Audio();
                this.audios[audio].src = this.loaded[audio];
            }
            this.audios[audio].setAttribute('active', '');
        }
    };
    engine.prototype.sprite = function (img, x, y, cx, cy, cw, ch, fx, fy) {
        if (!this.loaded.hasOwnProperty(img))
            throw "Error: File ".concat(img, " is not loaded");
        if (fx || fy) {
            this.ctx.save();
            this.ctx.scale(-1, 1);
        }
        this.ctx.drawImage(this.loaded[img], cx, cy, cw, ch, Math.round((fx ? -cw - x + this.camera[0] : x - this.camera[0]) * this.z), Math.round((fy ? -ch - y + this.camera[1] : y - this.camera[1]) * this.z), cw * this.z, ch * this.z);
        if (fx || fy)
            this.ctx.restore();
        if (this.sprite_boxed) {
            this.ctx.lineWidth = 1;
            this.ctx.strokeStyle = '#FF0000';
            this.ctx.strokeRect(Math.round((fx ? -cw - x + this.camera[0] : x - this.camera[0]) * this.z), Math.round((fy ? -ch - y + this.camera[1] : y - this.camera[1]) * this.z), cw * this.z, ch * this.z);
        }
    };
    engine.prototype.sprites = function (img, pos) {
        var _this = this;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (!this.loaded.hasOwnProperty(img))
            throw "Error: File ".concat(img, " is not loaded");
        // x, y, cx, cy, cw, ch, fx, fy, ra, rx, ry
        pos = [pos[0] || 0, pos[1] || 0, pos[2] || 1, pos[3] || 1];
        var data = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        args.forEach(function (arg) {
            data = arg = __spreadArray(__spreadArray([], arg, true), data.slice(arg.length), true);
            arg[0] += pos[0];
            arg[1] += pos[1];
            if (arg[6] || arg[7] || arg[8])
                _this.ctx.save();
            if (arg[6] || arg[7])
                _this.ctx.scale(-1, 1);
            if (arg[8]) {
                var rp = [(arg[0] + arg[9] - _this.camera[0]) * _this.z * (1 - 2 * arg[6]), (arg[1] + arg[10] - _this.camera[1]) * _this.z * (1 - 2 * arg[7])];
                _this.ctx.translate(rp[0], rp[1]);
                _this.ctx.rotate(arg[8] * (1 - 2 * arg[6]));
                _this.ctx.translate(-rp[0], -rp[1]);
                if (_this.rotate_boxed) {
                    _this.ctx.lineWidth = 1;
                    _this.ctx.strokeStyle = '#f00';
                    _this.ctx.beginPath();
                    _this.ctx.arc(rp[0], rp[1], 4 * _this.z, 0, Math.PI * 2);
                    _this.ctx.moveTo(rp[0], rp[1] - 5 * _this.z);
                    _this.ctx.lineTo(rp[0], rp[1] + 5 * _this.z);
                    _this.ctx.moveTo(rp[0] - 5 * _this.z, rp[1]);
                    _this.ctx.lineTo(rp[0] + 5 * _this.z, rp[1]);
                    _this.ctx.stroke();
                }
            }
            var dime = [
                Math.round((arg[6] ? -arg[4] - arg[0] + _this.camera[0] : arg[0] - _this.camera[0]) * _this.z),
                Math.round((arg[7] ? -arg[5] - arg[1] + _this.camera[1] : arg[1] - _this.camera[1]) * _this.z),
                arg[4] * _this.z * pos[2],
                arg[5] * _this.z * pos[3]
            ];
            _this.ctx.drawImage(_this.loaded[img], data[2], data[3], data[4], data[5], dime[0], dime[1], dime[2], dime[3]);
            if (_this.sprite_boxed) {
                _this.ctx.globalAlpha = 1;
                _this.ctx.lineWidth = 1;
                _this.ctx.strokeStyle = '#FF0000';
                _this.ctx.strokeRect(dime[0], dime[1], dime[2], dime[3]);
            }
            if (arg[6] || arg[7] || arg[8])
                _this.ctx.restore();
        });
    };
    engine.prototype.draw = function (type, data) {
        if (data == undefined)
            data = {};
        if (type == '') {
            data = __assign({ x: 0, y: 0, w: this.w, h: this.h, color: '#ffffff', alpha: 1, img: '' }, data);
            this.ctx.globalAlpha = data.alpha;
            if (data.img == '') {
                this.ctx.fillStyle = data.color;
                this.ctx.fillRect(data.x * this.z, data.y * this.z, data.w * this.z, data.h * this.z);
            }
            else {
                this.ctx.drawImage(this.loaded[data.img], data.x * this.z, data.y * this.z, data.w * this.z, data.h * this.z);
            }
            this.ctx.globalAlpha = 1;
        }
        else if (entities != undefined && entities.hasOwnProperty(type)) {
            data = __assign(__assign({}, entities[type].default), data);
            // @ts-ignore
            if (entities[type].hasOwnProperty('update'))
                entities[type].update(data, this, 0, 0);
            return;
        }
    };
    engine.prototype.render = function (p) {
        var _this = this;
        if (p == undefined)
            p = document.body;
        p.appendChild(this.dom);
        p.addEventListener('keydown', function (key) { return _this.evented[key.key] = { init: _this.evented[key.key] == undefined, alt: key.altKey, ctrl: key.ctrlKey }; });
        p.addEventListener('keyup', function (key) { return delete _this.evented[key.key]; });
    };
    ;
    // Entity
    engine.prototype.entity = function (type) {
        var _a;
        var arg = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            arg[_i - 1] = arguments[_i];
        }
        if (!entities.hasOwnProperty(type))
            throw "Error: No such entity \"".concat(type, "\"");
        var out = {};
        // @ts-ignore
        if (entities[type].hasOwnProperty('create'))
            out = (_a = entities[type]).create.apply(_a, __spreadArray([this], arg, false));
        else
            out = arg[0];
        out = __assign(__assign({ '__type__': type }, entities[type].default), out);
        return out;
    };
    engine.prototype.entities = function (type, len) {
        var arg = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            arg[_i - 2] = arguments[_i];
        }
        var out = [];
        for (var i = 0; i < len; i++)
            out.push(this.entity.apply(this, __spreadArray([type], arg, false)));
        return out;
    };
    engine.prototype.add_single = function (entity) {
        if (!entities.hasOwnProperty(entity['__type__']))
            throw "Error: No such entity \"".concat(entity['__type__'], "\"");
        // @ts-ignore
        entities[entity['__type__']].update(entity, this, (new Date()).getTime() - this.time_init.getTime(), (new Date()).getTime() - this.time_last.getTime());
        if (this.hitbox_boxed && entity.hitbox) {
            this.ctx.lineWidth = 1;
            // @ts-ignore
            for (var i = 0; i < entity.hitbox.length; i += 5) {
                this.ctx.strokeStyle = '#FFFF00';
                this.ctx.strokeRect((entity.hitbox[i + 1] - this.camera[0]) * this.z, (entity.hitbox[i + 2] - this.camera[1]) * this.z, entity.hitbox[i + 3] * this.z, entity.hitbox[i + 4] * this.z);
                this.ctx.strokeStyle = '#FF0000';
                this.ctx.beginPath();
                this.ctx.moveTo((entity.hitbox[i + 1] - this.camera[0]) * this.z, (entity.hitbox[i + 2] - this.camera[1]) * this.z);
                // @ts-ignore
                for (var j = 0; j < 4; j++)
                    this.ctx[entity.hitbox[i] >>> j & 1 ? 'lineTo' : 'moveTo']((entity.hitbox[i + 1] + entity.hitbox[i + 3] * (j < 2 ? 1 : 0) - this.camera[0]) * this.z, (entity.hitbox[i + 2] + entity.hitbox[i + 4] * (j == 1 || j == 2 ? 1 : 0) - this.camera[1]) * this.z);
                this.ctx.stroke();
            }
        }
    };
    engine.prototype.add = function () {
        var _this = this;
        var entities = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            entities[_i] = arguments[_i];
        }
        entities.forEach(function (entity) {
            if (Array.isArray(entity)) {
                entity.forEach(function (e) { return _this.add_single(e); });
            }
            else
                _this.add_single(entity);
        });
    };
    return engine;
}());
var level = function (main) { return [
    [
        // Background
        main.entity('background', { house: true }),
        // Platforms
        main.entity('plat', { x: 0, y: main.h - 16 * 6, w: 16, h: 7 }),
        main.entity('plat', { x: -10 * 16, y: main.h - 16, w: 16, h: 2, dropoff: false }),
        main.entity('plat', { x: 16 * 8, y: main.h - 16 * 4, w: 10, h: 5 }),
        // Dog
        main.entity('pet', { x: 15, y: 209 }),
        // Enemy
        main.entity('mananangal')
    ]
]; };
var level_collide = function (level) {
    var c = [
        level[0].slice(1, 4)
    ];
    level[0][4].collide = c[0];
    return c;
};
// Set gravity, game, levels, player, and player collisions
algo.gravity = 20;
var main = new engine({ z: 4, w: 320, h: 240, load: required_files });
var lv = level(main);
var player = main.entity('pinoy', { y: 195 });
var menu = main.entity('menu');
var collides = level_collide(lv);
player.collide = collides[0];
lv[0][4].follow = player;
// Level Scene
main.scene('level', function (t, dt) {
    if (dt > 100)
        return;
    //main.play('song/1st Temp BG Song (New Area).mp3');
    // Layers
    main.add(lv[0], player, menu);
    // Developer Tools
    if (main.on('x'))
        lv[0][0].darkmode = !lv[0][0].darkmode;
    main.on('z', function (e) {
        if (e.init)
            main.sprite_boxed = main.hitbox_boxed = main.rotate_boxed = !main.sprite_boxed;
    });
    // Player Controls
    main.on('Enter', function (e) {
        if (e.init && player.swinging < 0.1)
            player.swing = true;
    });
    if (main.on('w, ,ArrowUp') && player.ground != -1) {
        player.m[1] = 20;
        /*player.crouch = player.jumping = true;
        player.m[0] = 0;*/
    }
    else if (main.on('s,ArrowDown')) {
        player.crouch = true;
        player.m[0] = 0;
    }
    else if (player.crouch) {
        if (player.jumping)
            player.m[1] = 20;
        player.crouch = player.jumping = false;
    }
    else if (main.on('d,ArrowRight'))
        player.m[0] = 8;
    else if (main.on('a,ArrowLeft'))
        player.m[0] = -8;
    else
        player.m[0] = 0;
});
main.render();
</script></body></html>