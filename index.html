<!DOCTYPE html><html><head><title>Adventure Kingdom</title><style>body{background-color:#000}canvas{position:fixed;left:0;top:0;width:100%;height:100%;object-fit:contain;image-rendering:pixelated;z-index:1}h1{z-index:2;opacity:0}</style></head><body><script>var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var algo = {
    // Catalan Number, Dyck Word, Random Generation
    cdr: function (length) {
        if (length < 2)
            return length;
        var o = 0, x = 0, y = 0;
        for (var i = 0; i < 2 * length; i++) {
            if (x >= length)
                break;
            if (x == y || Math.random() < 0.5) {
                o += Math.pow(2, i);
                x++;
            }
            else
                y++;
        }
        return o;
    }, //cdr_it(s, z, (p, ht)
    cdr_it: function (seed, length, loop) {
        loop(3, 0, 0, true);
        var h = 1;
        for (var i = 1; i < length - 1; i++) {
            var p = seed & 3;
            seed = seed >> 2;
            if (p == 0)
                h--;
            loop(p, h, i, false);
            if (p == 3)
                h++;
        }
        loop(0, 0, length - 1, true);
    },
    gravity: function (vector, delta_time) {
        vector[1] -= (9 + vector[1]) * delta_time / 500;
        return vector[1] * delta_time / 60;
    },
    collision: function (entity, area) {
        var collide = [0, -1];
        var d = area == undefined ? 15 : area;
        entity.collide.forEach(function (collider, num) {
            if (entity.hitbox[0] & 4 && collider.hitbox[0] & 1 && (d & 4) == 4 &&
                entity.hitbox[2] + entity.hitbox[4] >= collider.hitbox[2] &&
                entity.hitbox[2] + entity.hitbox[4] < collider.hitbox[2] + collider.hitbox[4] &&
                entity.hitbox[1] < collider.hitbox[1] + collider.hitbox[3] &&
                entity.hitbox[1] + entity.hitbox[3] > collider.hitbox[1])
                collide = [4, num];
        });
        return collide;
    },
    collide: function (entity, area) {
        var collided = algo.collision(entity, area);
        if (collided[1] == -1)
            return false;
        if (collided[0] == 4)
            entity.hitbox[2] = entity.y = entity.collide[collided[1]].hitbox[2] - entity.hitbox[4];
        return true;
    },
    // Physics - Responsable for Momentum, Gravity, Collision
    /*physics: (entity:{m:number[], [index:string]:any}, dt:number, ...colliders:{[index:string]:any}[]) => {
        // Momentum
        
    }*/
};
var entities = {
    // Knight 
    knight: {
        default: { x: 0, y: 0,
            m: [0, -9], // Momentum Vector
            player: 0, // Player Number (0,1)
            right: true, // Facing Right?
            crouched: false, // Is crouching?
            on_ground: false, // Is on ground?
            jumping: false, // Is jumping?
            on_camera: true, // Is focused on camera?
            c: 0, // Crouchyness
            sword: 0, // Sword [-1:No Sword, 0->1:Swinging Sword]
            w: 0, // From 0 - 90
            s: [
                0, // Hair [red, blue]
                0, // Head [normal, duck]
                0, // Neck [normal, bend]
                0, // Walking animation [4 frames]
                0, // Hand swing [2 frames]
            ],
            hitbox: [], collide: []
        },
        update: function (d, o, t, dt) {
            //algo.physics(d, {})
            // Movement
            d.c += (d.crouched || d.sword > 0.1 ? dt / 100 : 0) - d.c * dt / 100;
            d.x += d.m[0] * dt / 60 * (2 - d.c) / 2;
            if (!d.on_ground)
                d.y -= algo.gravity(d.m, dt);
            d.on_ground = algo.collide(d, d.m[1] > 0 || (d.crouched && d.c > 0.9 && !d.jumping) ? 1 : 4);
            if (d.on_ground)
                d.m[1] = -9;
            d.right = d.m[0] == 0 ? d.right : d.m[0] > 0;
            var c = d.m[0] < 0 || !d.right ? 1 : 0;
            // Animation
            d.w = (d.w + Math.min(Math.abs(d.m[0]), 1) * dt + 50 * Math.sin(d.w / 240 * Math.PI) * (d.w < 120 ? -1 : 1) / (100 * Math.abs(d.m[0]) + 1)) % 240;
            var s = [
                (Math.sin((d.w - 60) / 120 * Math.PI) + 1) / 2, // Neck Bendyness [0->1]
                (d.w / 60) % 4, // Walking Animation [4 Frames]
                Math.sin((d.w / 120) % 2 * Math.PI / 2) * 2 * (1 - 2 * c), // Hand Swinging [2 Frames]
                (1 - Math.cos(t / 500)) * 0.25 // Breathing [0->0.25]
            ];
            // Camera focus
            if (d.on_camera) {
                o.camera[0] = d.x - o.w / 2;
                o.camera[1] = Math.min(0, d.y - o.h / 2);
            }
            // Render
            var parts = [
                // Hair
                [7 * c, s[0] * 1.8 + 2 * d.c * d.c - (1 - Math.abs(d.m[1]) / 9) + s[3], 32 + 4 * d.player, 0, 4, 5, c],
                // Leg Left
                [6 - c * 5 + (1 - Math.abs(d.m[1]) / 9 - s[1]) * (1 - 2 * c), 14, 36, 20, 4, 3],
                // Leg Right
                [2 + c * 3 - (1 - Math.abs(d.m[1]) / 9 - s[1]) * (1 - 2 * c), 14 - Math.min(s[1] * (4 - s[1]) / 3, 1)],
                // Hand Left
                [8 - s[2] - c * 8 + d.c - 2 * d.c * c, 10 + d.c * d.c - d.c, 33, 20, 3, 3, c, 0, 0],
                // Body
                [2, 11 + d.c * 0.5, 34, 17, 7, 3],
                // Hand Right
                [s[2] + c * 8 - d.c + 2 * d.c * c, 10 + d.c * d.c - d.c, 33, 20, 3, 3],
                // Chest
                [0, 6 + s[0] * 0.7 + d.c + s[3] / 2, 32, 12, 11, 5],
                // Head
                [2, 1 + s[0] + 2 * d.c - (1 - Math.abs(d.m[1]) / 9) + s[3], 32 + 6 * Math.round(d.c), 5, 7, 7]
            ];
            // Sword
            if (d.sword != -1) {
                if (d.sword < 0.5)
                    parts.splice(3, 0, [(c ? -3 : 10) - s[2] + d.c - 2 * d.c * c, 5, 45, 5, 4, 7, c, 0, d.sword * 2, c ? 3 : 0, 6]);
                else
                    parts.splice(8, 0, [(c ? -9 : 0) + d.c - 2 * d.c * c, 7 + d.c + s[3] / 2, 49, 5, 20, 8]);
                d.sword -= d.sword * dt / 100;
            }
            o.sprites.apply(o, __spreadArray(['sprites.png', [d.x, d.y]], parts, false));
            // Hitbox
            d.hitbox = [15,
                d.x, d.y,
                11, 16
            ];
        }
    },
    // Dirt Entity
    dirt: {
        default: { x: 0, y: 0, w: 0, h: 0, hitbox: [] },
        update: function (d, o, t, dt) {
            for (var i = 0; i < d.w; i++)
                for (var j = 0; j < d.h; j++)
                    o.sprite('sprites.png', d.x + i * 8, d.y + j * 8, i == 0 ? 0 : i + 1 >= d.w ? 8 : 4, j == 0 ? 0 : j + 1 >= d.h ? 12 : 8, 8, 8);
        },
        create: function (o, a) {
            return __assign({ hitbox: [1, a.x + 4, a.y, a.w * 8 - 8, 8] }, a);
        }
    },
    liquid: {
        default: { x: 0, y: 0, w: 0, h: 0, lava: false },
        update: function (d, o, t, dt) {
            var f = Math.floor(t / 200 * (d.lava ? 1 : 1.5)) % 4;
            for (var i = 0; i < d.w; i++)
                for (var j = 1; j < d.h * 2 - 1; j++)
                    o.sprite('sprites.png', d.x + i * 8, d.y + 4 * j, (i + f + j) % 2 * 8 + (d.lava ? 16 : 0), 35 + Math.floor((i + f + j) / 2) % 2 * 8, 8, 8);
        }
    },
    eud: {
        default: { x: 0, y: 0, w: 0, h: 0, seed: 0, s: 0, t: 0, hp: 0 },
        update: function (d, o, t, dt) {
            if (d.t == 0) {
                d.x += d.s * dt / 1000;
                if (d.x > o.w)
                    d.x = -d.w * 8;
            }
            algo.cdr_it(d.seed, d.w, function (p, h, x, e) {
                var m = Math.abs(2 * p - 3) == 1 ? 4 : 0;
                for (var j = 0; j < h + d.hp; j++)
                    o.sprite('sprites.png', d.x + x * 8, d.y - j * 8 - 8, 8, 63 - 8 - (j == 0 ? 0 : 1) + d.t * 12, 8, 8);
                o.sprite('sprites.png', d.x + x * 8, d.y - (h + d.hp) * 8 + (m == 4 ? 5 : 0) - 8, [16, 8, 8, 0][p], 55 - m - (m == 0 ? 1 : 0) + d.t * 12 + (e ? 1 : 0), 8, 8 - (m == 4 ? 5 : 0));
            });
        },
        create: function (o, arg) {
            var w = arg != undefined && arg.w ? arg.w : Math.floor(Math.random() * 12) + 2;
            var h = 0;
            var s = algo.cdr(w - 2);
            algo.cdr_it(s, w, function (p, ht) { return h = Math.max(ht, h); });
            var x = Math.floor(Math.pow(Math.random(), 3) * (o.w / o.z + w * 8)) - w * 4;
            var y = Math.floor(Math.pow(Math.random(), 3) * (o.h / o.z - h * 24)) + (h + 1) * 8;
            return __assign({ x: x, y: y, w: w, h: h + 1, seed: s, s: Math.random() * 5 + 1 }, arg);
        }
    }
};
var engine = /** @class */ (function () {
    function engine(args) {
        var _this = this;
        this.fps = 60; // Frames per second
        this.camera = [0, 0];
        // Loader
        this.loaded = {}; // Loaded data in cache
        this.evented = {}; // Recorded events
        this.events = {}; // Global event listeners
        this.scenes = {}; // Scenes
        this.active_scene = ''; // Active Scene
        this.path = ''; // Current path of action (scene)
        // Drawing
        this.sprite_boxed = false;
        this.hitbox_boxed = false;
        this.rotate_boxed = false;
        // Initalize Canvas
        args = args === undefined ? {} : args;
        var data = __assign({ dom: document.createElement('canvas'), w: 320, h: 240 }, args);
        Object.keys(data).forEach(function (key) {
            _this[key] = data[key];
        });
        this.dom.setAttribute('width', String(this.w * this.z));
        this.dom.setAttribute('height', String(this.h * this.z));
        this.ctx = this.dom.getContext('2d');
        this.ctx.imageSmoothingEnabled = false;
    }
    engine.prototype.loadcheck = function (percent) {
        var _this = this;
        this.ctx.fillRect((this.w * 0.25 + 2) * this.z, (this.h * 0.45 + 2) * this.z, percent * (this.w * 0.5 - 4) * this.z, (this.h * 0.1 - 4) * this.z);
        if (percent < 1)
            return;
        var check = function () {
            for (var i = 0; i < Object.keys(_this.loaded).length; i++)
                if (Object.keys(_this.loaded)[i].slice(-4) == '.ttf' && !document.fonts.check("20px ".concat(Object.keys(_this.loaded)[i].slice(0, -4)))) {
                    setTimeout(check, 10);
                    return;
                }
            _this.start_loop();
        };
        check();
    };
    engine.prototype.load = function () {
        var _this = this;
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        var loaded = [];
        // Loading Menu
        this.ctx.lineWidth = this.z;
        this.ctx.strokeStyle = this.ctx.fillStyle = '#FFFFFF';
        this.ctx.strokeRect(this.w * this.z * 0.25, this.h * this.z * 0.45, this.w * this.z * 0.5, this.h * this.z * 0.1);
        // Loading Files
        files.forEach(function (file, i) {
            if (file.slice(-4) == '.png') {
                _this.loaded[file] = new Image();
                _this.loaded[file].src = '/asset/' + file;
                _this.loaded[file].onload = function () {
                    loaded[i] = 4;
                    _this.loadcheck(loaded.reduce(function (pre, cur) { return pre + cur; }) / files.length / 4);
                };
            }
            else if (file.slice(-4) == '.ttf') {
                loaded[i] = 0;
                _this.loaded[file] = '';
                var h_1 = new XMLHttpRequest();
                h_1.open('GET', '/asset/' + file);
                h_1.responseType = 'blob';
                h_1.onreadystatechange = function () {
                    loaded[i] = h_1.readyState;
                    _this.loadcheck(loaded.reduce(function (pre, cur) { return pre + cur; }) / files.length / 4);
                    if (h_1.readyState != 4 || h_1.status != 200)
                        return;
                    _this.loaded[file] = URL.createObjectURL(h_1.response);
                    var d = document.createElement('h1');
                    d.style.font = "20px ".concat(file.slice(0, -4));
                    d.innerHTML = file.slice(0, -4);
                    var s = document.createElement('style');
                    s.innerHTML += "@font-face {font-family:\"".concat(file.slice(0, -4), "\";src:url(\"").concat(_this.loaded[file], "\") format(\"truetype\");}");
                    document.head.appendChild(s);
                    document.body.appendChild(d);
                };
            }
        });
    };
    engine.prototype.check_event = function (event, action) {
        var events = event.split(',');
        var index = -1;
        for (var i = 0; i < Object.keys(this.evented).length; i++) {
            if (events.indexOf(Object.keys(this.evented)[i]) != -1) {
                index = i;
                break;
            }
        }
        if (index != -1 && action != undefined) {
            action(this.evented[Object.keys(this.evented)[index]]);
            this.evented[Object.keys(this.evented)[index]]['init'] = false;
        }
        return index != -1;
    };
    engine.prototype.loop = function () {
        var _this = this;
        var now = new Date();
        if (this.active_scene.length != 0) {
            this.path = this.active_scene;
            this.scenes[this.active_scene](now.getTime() - this.time_init.getTime(), now.getTime() - this.time_last.getTime());
            this.path = '';
        }
        Object.keys(this.events).forEach(function (e) {
            _this.events[e].forEach(function (a) { return _this.check_event(e, a); });
            if (_this.events[e].hasOwnProperty('init'))
                _this.events[e]['init'] = false;
        });
        this.time_last = new Date();
    };
    engine.prototype.start_loop = function () {
        this.time_init = new Date();
        this.time_last = new Date();
        this.looper = setInterval(this.loop.bind(this), 1000 / this.fps);
    };
    engine.prototype.stop_loop = function () {
        clearInterval(this.looper);
    };
    engine.prototype.scene = function (id, scene) {
        if (scene == undefined || this.active_scene.length == 0)
            this.active_scene = id;
        if (scene != undefined)
            this.scenes[id] = scene;
    };
    engine.prototype.on = function (event, action) {
        if (this.path.length == 0) {
            if (action == undefined)
                throw "Error: Action in \"engine.on\" must be decleared if not inside scene";
            if (!this.events.hasOwnProperty(event))
                this.events[event] = [];
            this.events[event].push(action);
            return false;
        }
        return this.check_event(event, action);
    };
    engine.prototype.sprite = function (img, x, y, cx, cy, cw, ch, fx, fy) {
        if (!this.loaded.hasOwnProperty(img))
            throw "Error: File ".concat(img, " is not loaded");
        if (fx || fy) {
            this.ctx.save();
            this.ctx.scale(-1, 1);
        }
        this.ctx.drawImage(this.loaded[img], cx, cy, cw, ch, Math.round((fx ? -cw - x + this.camera[0] : x - this.camera[0]) * this.z), Math.round((fy ? -ch - y + this.camera[1] : y - this.camera[1]) * this.z), cw * this.z, ch * this.z);
        if (fx || fy)
            this.ctx.restore();
        if (this.sprite_boxed) {
            this.ctx.lineWidth = 1;
            this.ctx.strokeStyle = '#FF0000';
            this.ctx.strokeRect(Math.round((fx ? -cw - x + this.camera[0] : x - this.camera[0]) * this.z), Math.round((fy ? -ch - y + this.camera[1] : y - this.camera[1]) * this.z), cw * this.z, ch * this.z);
        }
    };
    engine.prototype.sprites = function (img, pos) {
        var _this = this;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (!this.loaded.hasOwnProperty(img))
            throw "Error: File ".concat(img, " is not loaded");
        // x, y, cx, cy, cw, ch, fx, fy, ra, rx, ry
        pos = [pos[0] || 0, pos[1] || 0, pos[2] || 1, pos[3] || 1];
        var data = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        args.forEach(function (arg) {
            data = arg = __spreadArray(__spreadArray([], arg, true), data.slice(arg.length), true);
            arg[0] += pos[0];
            arg[1] += pos[1];
            if (arg[6] || arg[7] || arg[8])
                _this.ctx.save();
            if (arg[6] || arg[7])
                _this.ctx.scale(-1, 1);
            if (arg[8]) {
                var rp = [(arg[0] + arg[9] - _this.camera[0]) * _this.z * (1 - 2 * arg[6]), (arg[1] + arg[10] - _this.camera[1]) * _this.z * (1 - 2 * arg[7])];
                _this.ctx.translate(rp[0], rp[1]);
                _this.ctx.rotate(arg[8] * (1 - 2 * arg[6]));
                _this.ctx.translate(-rp[0], -rp[1]);
                if (_this.rotate_boxed) {
                    _this.ctx.lineWidth = 1;
                    _this.ctx.strokeStyle = '#f00';
                    _this.ctx.beginPath();
                    _this.ctx.arc(rp[0], rp[1], 4 * _this.z, 0, Math.PI * 2);
                    _this.ctx.moveTo(rp[0], rp[1] - 5 * _this.z);
                    _this.ctx.lineTo(rp[0], rp[1] + 5 * _this.z);
                    _this.ctx.moveTo(rp[0] - 5 * _this.z, rp[1]);
                    _this.ctx.lineTo(rp[0] + 5 * _this.z, rp[1]);
                    _this.ctx.stroke();
                }
            }
            var dime = [
                Math.round((arg[6] ? -arg[4] - arg[0] + _this.camera[0] : arg[0] - _this.camera[0]) * _this.z),
                Math.round((arg[7] ? -arg[5] - arg[1] + _this.camera[1] : arg[1] - _this.camera[1]) * _this.z),
                arg[4] * _this.z * pos[2],
                arg[5] * _this.z * pos[3]
            ];
            _this.ctx.drawImage(_this.loaded[img], data[2], data[3], data[4], data[5], dime[0], dime[1], dime[2], dime[3]);
            if (_this.sprite_boxed) {
                _this.ctx.globalAlpha = 1;
                _this.ctx.lineWidth = 1;
                _this.ctx.strokeStyle = '#FF0000';
                _this.ctx.strokeRect(dime[0], dime[1], dime[2], dime[3]);
            }
            if (arg[6] || arg[7] || arg[8])
                _this.ctx.restore();
        });
    };
    engine.prototype.draw = function (type, data) {
        if (data == undefined)
            data = {};
        if (type == '') {
            data = __assign({ x: 0, y: 0, w: this.w, h: this.h, color: '#ffffff', alpha: 1, img: '' }, data);
            this.ctx.globalAlpha = data.alpha;
            if (data.img == '') {
                this.ctx.fillStyle = data.color;
                this.ctx.fillRect(data.x * this.z, data.y * this.z, data.w * this.z, data.h * this.z);
            }
            else {
                this.ctx.drawImage(this.loaded[data.img], data.x * this.z, data.y * this.z, data.w * this.z, data.h * this.z);
            }
            this.ctx.globalAlpha = 1;
        }
        else if (entities != undefined && entities.hasOwnProperty(type)) {
            data = __assign(__assign({}, entities[type].default), data);
            // @ts-ignore
            if (entities[type].hasOwnProperty('update'))
                entities[type].update(data, this, 0, 0);
            return;
        }
    };
    engine.prototype.render = function (p) {
        var _this = this;
        if (p == undefined)
            p = document.body;
        p.appendChild(this.dom);
        p.addEventListener('keydown', function (key) { return _this.evented[key.key] = { init: _this.evented[key.key] == undefined, alt: key.altKey, ctrl: key.ctrlKey }; });
        p.addEventListener('keyup', function (key) { return delete _this.evented[key.key]; });
    };
    ;
    // Entity
    engine.prototype.entity = function (type) {
        var _a;
        var arg = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            arg[_i - 1] = arguments[_i];
        }
        if (!entities.hasOwnProperty(type))
            throw "Error: No such entity \"".concat(type, "\"");
        var out = {};
        // @ts-ignore
        if (entities[type].hasOwnProperty('create'))
            out = (_a = entities[type]).create.apply(_a, __spreadArray([this], arg, false));
        else
            out = arg[0];
        out = __assign(__assign({ '__type__': type }, entities[type].default), out);
        return out;
    };
    engine.prototype.entities = function (type, len) {
        var arg = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            arg[_i - 2] = arguments[_i];
        }
        var out = [];
        for (var i = 0; i < len; i++)
            out.push(this.entity.apply(this, __spreadArray([type], arg, false)));
        return out;
    };
    engine.prototype.add_single = function (entity) {
        if (!entities.hasOwnProperty(entity['__type__']))
            throw "Error: No such entity \"".concat(entity['__type__'], "\"");
        // @ts-ignore
        entities[entity['__type__']].update(entity, this, (new Date()).getTime() - this.time_init.getTime(), (new Date()).getTime() - this.time_last.getTime());
        if (this.hitbox_boxed && entity.hitbox) {
            this.ctx.lineWidth = 1;
            // @ts-ignore
            for (var i = 0; i < entity.hitbox.length; i += 5) {
                this.ctx.strokeStyle = '#FFFF00';
                this.ctx.strokeRect((entity.hitbox[i + 1] - this.camera[0]) * this.z, (entity.hitbox[i + 2] - this.camera[1]) * this.z, entity.hitbox[i + 3] * this.z, entity.hitbox[i + 4] * this.z);
                this.ctx.strokeStyle = '#FF0000';
                this.ctx.beginPath();
                this.ctx.moveTo((entity.hitbox[i + 1] - this.camera[0]) * this.z, (entity.hitbox[i + 2] - this.camera[1]) * this.z);
                // @ts-ignore
                for (var j = 0; j < 4; j++)
                    this.ctx[entity.hitbox[i] >>> j & 1 ? 'lineTo' : 'moveTo']((entity.hitbox[i + 1] + entity.hitbox[i + 3] * (j < 2 ? 1 : 0) - this.camera[0]) * this.z, (entity.hitbox[i + 2] + entity.hitbox[i + 4] * (j == 1 || j == 2 ? 1 : 0) - this.camera[1]) * this.z);
                this.ctx.stroke();
            }
        }
    };
    engine.prototype.add = function () {
        var _this = this;
        var entities = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            entities[_i] = arguments[_i];
        }
        entities.forEach(function (entity) {
            if (Array.isArray(entity)) {
                entity.forEach(function (e) { return _this.add_single(e); });
            }
            else
                _this.add_single(entity);
        });
    };
    return engine;
}());
// @ts-ignore
entities = __assign(__assign({}, entities), { 
    // Pinoy Entitiy
    pinoy: {
        default: {
            x: 0, y: 200, m: [0, 0],
            isdead: false, // Is character dead?
            crouch: false, // Is character crouching?
            ground: false, // Is character standing on ground?
            fright: true, // Is character facing right?
            camera: true, // Is camera on character?
        },
        update: function (d, o, t, dt) {
            d.fright = d.m[0] > 0 ? true : d.m[0] < 0 ? false : d.fright;
            d.x += d.m[0] * dt / 10;
            d.y -= d.m[1] * dt / 50;
            // Temporary Ground
            if (d.y >= 200) {
                d.ground = true;
                d.y = 200;
                d.m[1] = 0;
            }
            else {
                d.ground = false;
                d.y -= algo.gravity(d.m, dt);
            }
            // Camera
            if (d.camera) {
                o.camera[0] = d.x - o.w / 2;
            }
            o.sprites('McCombinedNew2.png', [d.x, d.y], [0, 0,
                !d.ground ? 32 * 15 : d.crouch ? 32 * 14 : Math.abs(d.m[0]) > 0.5 ? 32 * (2 + Math.floor(t / 75) % 12) : 32 * Math.floor(t / 100) % 2, 0,
                32, 32,
                d.fright ? 0 : 1
            ]);
        }
    }, 
    // Background Entity
    background: {
        default: {
            darkmode: false,
            dark: 0
        },
        update: function (d, o, t, dt) {
            if (d.darkmode)
                d.dark += (1 - d.dark) * dt / 1000;
            else
                d.dark -= d.dark * dt / 1000;
            o.draw('', { img: 'normal bg.png' });
            o.draw('', { img: 'dark bg.png', alpha: d.dark });
        }
    }, dog: {
        default: { x: 0, y: 220, running: true },
        update: function (d, o, t, dt) {
            o.sprites('Dog.png', [d.x, d.y], [0, 0, (d.running ? 1 + Math.floor(t / 100) % 2 : 0) * 32 + 3, 8, (38 + 14) / 2, 15]);
        }
    }, cat: {
        default: { x: 0, y: 220, running: true },
        update: function (d, o, t, dt) {
            o.sprites('Cat (1).png', [d.x, d.y], [0, 0, (d.running ? 1 + Math.floor(t / 100) % 2 : 0) * 16, 0, 16, 16]);
        }
    }, king: {
        default: { x: 0, y: 100,
            wing_angle: 0
        },
        update: function (d, o, t, dt) {
            d.wing_angle = Math.sin(t / 150);
            o.sprites('Aswang King.png', [d.x, d.y], 
            // Right wing
            [61, 1 + Math.sin(t / 200), 35, 0, 35, 18, 0, 0, -d.wing_angle, 0, 18], 
            // Left wing
            [0, Math.sin(t / 200), 0, 0, 35, 18, 0, 0, d.wing_angle, 35], 
            // Left hand
            [1, 24 + Math.sin(t / 200) / 2, 0, 18, 23, 21, 0, 0, 0], 
            // Right hand
            [66, 24 + Math.sin(t / 200) / 2, 23, 18, 23, 21], 
            // Body
            [28, 13 + Math.sin(t / 200), 0, 39, 37, 52], 
            // Head
            [41, 1 + Math.sin(t / 200) * 2, 70, 0, 13, 18]);
        }
    } });
var debug = false;
var main = new engine({
    z: 4, w: 320, h: 240, sprite_boxed: debug, rotate_boxed: debug
});
var back = main.entity('background', { darkmode: true, dark: 1 });
var player = main.entity('pinoy');
var pet = [main.entity('dog'), main.entity('cat', { x: 32 })];
var king = main.entity('king');
main.load('dark bg.png', 'normal bg.png', 'normal clouds.png', 'Dog.png', 'Cat (1).png', 'Aswang King.png', 'McCombinedNew2.png');
main.scene('menu', function (t, dt) {
    main.add(back, player, pet, king);
    if (main.on('x'))
        back.darkmode = !back.darkmode;
    if (main.on('w, ,ArrowUp') && player.ground) {
        player.crouch = true;
        player.m[0] = 0;
    }
    else if (player.crouch) {
        player.m[1] = 10;
        player.crouch = false;
    }
    else if (main.on('d,ArrowRight'))
        player.m[0] = 1;
    else if (main.on('a,ArrowLeft'))
        player.m[0] = -1;
    else
        player.m[0] = 0;
});
main.render();
</script></body></html>